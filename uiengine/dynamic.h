#ifndef DYNAMIC_H__
#define DYNAMIC_H__

#include <stdio.h>
#include <string.h>
#include <string>

namespace dynamic
{
	void *create( const char* creation_tag );
	//------------------------------------------------------------------
	class abstract_factory
	{
	public:
		virtual void *create_obj( const char* creation_tag ) = 0;
	};
	//------------------------------------------------------------------
	class factory_list_ele
	{
		friend void *create( const char* creation_tag );
	
		static factory_list_ele	*head;
		factory_list_ele		*next;
		abstract_factory		*manufacturer;
	public:
		factory_list_ele( abstract_factory *fact );
		virtual ~factory_list_ele( void );
	};
	//------------------------------------------------------------------
	inline factory_list_ele::factory_list_ele(  abstract_factory *fact )
							: manufacturer( fact )
	{
		next = head;
		head = this;
	}
	//------------------------------------------------------------------
	// disable Warning C4355: "'this' used in base member initializer
	// list." The warning is generated by the initialzation list of the
	// factory<t> constructor. The warning is noise in the current context,
	// because "manufacturer" is not actually a base class. The pragma
	// must be at the global level because the warning is kicked out
	// every time the template is expanded.
#ifdef WIN32
	#pragma	warning(disable : 4355)
#endif
	//------------------------------------------------------------------
	// The "manufacturer" field isn't static because I want to initialize
	// it in the constructor. This way I can avoid having to define one
	// for every template expansion. This means that you might have more
	// than one manufacturer for a given class (if you declare several
	// factories for the same class, for example), but it's a harmless
	// error.
	template <class t>
	class factory: public abstract_factory
	{
		factory_list_ele manufacturer;
													  
	public:
		factory( const char* tag ): manufacturer( this )
		{
			this->tag = tag;
		}

		virtual ~factory(){}
		void *create_obj( const char* creation_tag )
		{
			if( strcmp(creation_tag, tag) )return 0;
			return (void*)( new t );
		}
	private:
		const char* tag;
	};
}
#endif // DYNAMIC_H__
